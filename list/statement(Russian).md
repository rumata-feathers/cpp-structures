### List and StackAllocator [C++ spring 2022]

<table>
<thead>
<tr>
<th>Ограничение времени</th>
<th>10 секунд</th>
</tr>
<tr>
<th>Ограничение памяти</th>
<th>512Mb</th>
</tr>
<tr>
<th>Ввод</th>
<th>стандартный ввод или input.txt</th>
</tr>
<tr>
<th>Вывод</th>
<th>стандартный вывод или output.txt</th>
</tr>
</thead>
</table>

#### Часть 1.
Напишите класс _StackAllocator<typename T, size_t N>_, который бы позволял создавать стандартные контейнеры на стеке, без единого обращения к динамической памяти. Для этого вам пригодится написать класс _StackStorage<size_t N>_. Объект класса _StackAllocator_ должен быть легковесным, легко копироваться и присваиваться. Объект _StackStorage_, напротив, не должен поддерживать копирование.  
Класс _StackAllocator_ должен удовлетворять требованиям к аллокатору, описанным на странице https://en.cppreference.com/w/cpp/named_req/Allocator. Он должен быть _STL_-совместимым. В частности, должны быть определены:  
Конструктор по умолчанию, конструктор копирования, деструктор, оператор присваивания;

Во время исполнения может существовать несколько StackStorage с одним и тем же _N_. Разумеется, аллокаторы, построенные на разных StackStorage, должны считаться неравными.  
_StackAllocator_ должен заботиться о выравнивании объектов. 
Использование любого контейнера со _StackAllocator_ вместо _std::allocator_ должно приводить к тому, что обращений к динамической памяти в программе не происходит вообще.
#### Часть 2.
Напишите класс _List_ - двусвязный список с правильным использованием аллокатора. Правильное использование аллокатора означает, что ваш лист должен удовлетворять требованиям https://en.cppreference.com/w/cpp/named_req/AllocatorAwareContainer. Должно быть два шаблонных параметра: _T_ - тип элементов в листе, _Allocator_ - тип используемого аллокатора (по умолчанию - _std::allocator<T>_).  
Должны быть поддержаны:  
- Конструкторы: 
  - без параметров;
  - от одного числа;
  - от числа и _const T&_;
  - от одного аллокатора;
  - от числа и аллокатора;
  - от числа, _const T&_ и аллокатора.
- Метод _get_allocator()_, возвращающий объект аллокатора, используемый в листе на данный момент;
- Конструктор копирования, деструктор, копирующий оператор присваивания;
- Метод _size()_, работающий за _O(1)_;
- Методы _push_back, push_front, pop_back, pop_front_;
- Двунаправленные итераторы, удовлетворяющие требованиям https://en.cppreference.com/w/cpp/named_req/BidirectionalIterator. Также поддержите константные и _reverse_-итераторы;
- Методы _begin, end, cbegin, cend, rbegin, rend, crbegin, crend_;
- Методы _insert(iterator, const T&)_, а также _erase(iterator)_ - для удаления и добавления одиночных элементов в список.

Все методы листа должны быть строго безопасны относительно исключений. Это означает, что при выбросе исключения из любого метода класса _T_ во время произвольной операции _X_ над листом лист должен вернуться в состояние, которое было до начала выполнения _X_, не допустив _UB_ и утечек памяти, и пробросить исключение наверх в вызывающую функцию. Можно считать, что конструкторы и операторы присваивания у аллокаторов исключений никогда не кидают (это является частью требований к _Allocator_).
Проверьте себя еще раз: выполните последовательность случайных добавлений-удалений элементов в _List<int, StackAllocator<int, 100000> >_. Работает ли это быстрее, чем для _List<int, std::allocator<int> >_?
Как ваш собственный _List_, так и _std::list_ должен показывать более высокую производительность со _StackAllocator_’ом, чем со стандартным аллокатором. В контесте это будет проверяться путем замеров времени выполнения большого количества однотипных операций над листом. Если ваш аллокатор проиграет по времени стандартному аллокатору, вы не пройдете тесты.