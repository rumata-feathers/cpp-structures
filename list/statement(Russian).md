### List and StackAllocator [C++ spring 2022]

<table>
<thead>
<tr>
<th>Ограничение времени</th>
<th>10 секунд</th>
</tr>
<tr>
<th>Ограничение памяти</th>
<th>512Mb</th>
</tr>
<tr>
<th>Ввод</th>
<th>стандартный ввод или input.txt</th>
</tr>
<tr>
<th>Вывод</th>
<th>стандартный вывод или output.txt</th>
</tr>
</thead>
</table>
  
Предупреждение: формально следующие задачи не будут зависеть от этой, то есть для получения баллов по любой из остальных задач не будет требоваться, чтобы эта задача была сдана. Однако код, написанный в этой задаче, пригодится для переиспользования в следующей задаче.
В этой задаче вам предлагается научиться пользоваться аллокаторами, а также разобраться с устройством контейнера list и понять, что иногда нестандартный аллокатор может давать выигрыш в производительности по сравнению со стандартным.
#### Часть 1.
Напишите класс _StackAllocator<typename T, size_t N>_, который бы позволял создавать стандартные контейнеры на стеке, без единого обращения к динамической памяти. Для этого вам пригодится написать класс _StackStorage<size_t N>_, в котором будет храниться большой массив на стеке. Объект класса _StackAllocator_ должен быть легковесным, легко копироваться и присваиваться. Объект _StackStorage_, напротив, не должен поддерживать копирование.  
Класс _StackAllocator_ должен удовлетворять требованиям к аллокатору, описанным на странице https://en.cppreference.com/w/cpp/named_req/Allocator. Он должен быть _STL_-совместимым, то есть позволять использование в качестве аллокатора для стандартных контейнеров. В частности, должны быть определены:  
Конструктор по умолчанию, конструктор копирования, деструктор, оператор присваивания;  
Методы _allocate, deallocate_;  
Внутренний тип _value_type_;  
Метод _select_on_container_copy_construction_, если логика работы вашего аллокатора этого потребует.
Пример того, как может использоваться   
_StackAllocator:  
int main() {  
StackStorage<100'000> storage;  
StackAllocator<int, 100'000> alloc(storage);  
std::vector<int, StackAllocator<int, 100'000» v(alloc);  
// ... useful stuff ...  
}_  
Во время исполнения может существовать несколько StackStorage с одним и тем же _N_. Разумеется, аллокаторы, построенные на разных StackStorage, должны считаться неравными.  
_StackAllocator_ должен заботиться о выравнивании объектов. В частности, нельзя класть переменные типа _int_ по адресам, не кратным 4; переменные типа _double_ - по адресам, не кратным 8, и т.д..  
Использование любого контейнера со _StackAllocator_ вместо _std::allocator_ должно приводить к тому, что обращений к динамической памяти в программе не происходит вообще.  
Проверьте себя: напишите тестирующую функцию, которая создает _std::list_ и выполняет над ним последовательность случайных добавлений/удалений элементов. Если вы все сделали правильно, то _std::list_ со _StackAllocator_'ом должен работать быстрее, чем _std::list_ со стандартным аллокатором.

#### Часть 2.
Напишите класс _List_ - двусвязный список с правильным использованием аллокатора. Правильное использование аллокатора означает, что ваш лист должен удовлетворять требованиям https://en.cppreference.com/w/cpp/named_req/AllocatorAwareContainer. Должно быть два шаблонных параметра: _T_ - тип элементов в листе, _Allocator_ - тип используемого аллокатора (по умолчанию - _std::allocator<T>_).  
Должны быть поддержаны:  
- Конструкторы: 
  - без параметров;
  - от одного числа;
  - от числа и _const T&_;
  - от одного аллокатора;
  - от числа и аллокатора;
  - от числа, _const T&_ и аллокатора.
- Метод _get_allocator()_, возвращающий объект аллокатора, используемый в листе на данный момент;
- Конструктор копирования, деструктор, копирующий оператор присваивания;
- Метод _size()_, работающий за _O(1)_;
- Методы _push_back, push_front, pop_back, pop_front_;
- Двунаправленные итераторы, удовлетворяющие требованиям https://en.cppreference.com/w/cpp/named_req/BidirectionalIterator. Также поддержите константные и _reverse_-итераторы;
- Методы _begin, end, cbegin, cend, rbegin, rend, crbegin, crend_;
- Методы _insert(iterator, const T&)_, а также _erase(iterator)_ - для удаления и добавления одиночных элементов в список.

Все методы листа должны быть строго безопасны относительно исключений. Это означает, что при выбросе исключения из любого метода класса _T_ во время произвольной операции _X_ над листом лист должен вернуться в состояние, которое было до начала выполнения _X_, не допустив _UB_ и утечек памяти, и пробросить исключение наверх в вызывающую функцию. Можно считать, что конструкторы и операторы присваивания у аллокаторов исключений никогда не кидают (это является частью требований к _Allocator_).
Проверьте себя еще раз: выполните последовательность случайных добавлений-удалений элементов в _List<int, StackAllocator<int, 100000> >_. Работает ли это быстрее, чем для _List<int, std::allocator<int> >_?
Как ваш собственный _List_, так и _std::list_ должен показывать более высокую производительность со _StackAllocator_’ом, чем со стандартным аллокатором. В контесте это будет проверяться путем замеров времени выполнения большого количества однотипных операций над листом. Если ваш аллокатор проиграет по времени стандартному аллокатору, вы не пройдете тесты.